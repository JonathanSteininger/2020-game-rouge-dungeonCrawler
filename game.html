<!doctype html>
<html lang="en">

<head>
    <title>JavaScript</title>
</head>

<body>
    <canvas id="gameCanvas" width="600" height="400">
        <script>
            var canvas, canvasContext;
            window.onload = function() {
                canvas = document.getElementById('gameCanvas');
                canvasContext = canvas.getContext('2d');

                document.addEventListener('keydown', keyPressed); // sets the event for the keypressed func 
                document.addEventListener('keyup', keyReleased); // sets the event for the keyreleased func 

                setInterval(
                    mainloop, 1000 / 50); // starts the game loop

                creatGrid(); // creates the grid for the entier game
                loadLevels(); // creates all the levels walls
                drawGrid(); //darws background once
                drawWalls(); //draws walls onsce

            }

            function mainloop() {
                if (timerMove >= 5 && gamerun == false) { // makes it so theres a clean interuption to your movement
                    playerMovement();
                } else {
                    timerMove++;
                }
                
                //                console.log(test2);
                if (gamerun == true) { // makes it so that other things only get drawn if you move. helps for future games. can be removed.
                    if (timer >= 4) {// sets the animation of th eplayers maovment
                        imgLoad(floorImg, grid[wallCheckX][0], grid[wallCheckY][1], horizontalsize, verticalsize);//draws the vfinal floor under th eplayers past position
                        imgLoad(floorImg, grid[playerXPosition][0], grid[playerYPosition][1], horizontalsize, verticalsize);//drwas the final floor under the player
                        imgLoad(playerImg, grid[playerXPosition][0], grid[playerYPosition][1], horizontalsize, verticalsize); //draws the players final position
                        gamerun = false;// makes it that this function will only run after th eplayermovement function has run
                        timer = 0;//restets timer
                    } else {
                        imgLoad(floorImg, grid[playerXPosition][0], grid[playerYPosition][1], horizontalsize, verticalsize);
                        drawPlayer(); //draws the player
                        timer++;// +1 to timer2
                    }
                    
                }else{
                    if (timer2 >=2){
                        
                        imgLoad(floorImg, grid[playerXPosition][0], grid[playerYPosition][1], horizontalsize, verticalsize);
                        imgLoad2(playerImgMain, timer3*40, frameY*40, playerSpriteWidth, playerSpriteHeight,grid[playerXPosition][0], grid[playerYPosition][1], horizontalsize, verticalsize);
                        if (timer3 >=9){
                            timer3 = 0;
                        }else{
                            timer3++
                        }
                        timer2 = 0;
                    }else{
                        timer2++;
                    }
                }
            }
            //mainloop timers and ifs
            var timer = 0;
            var gamerun = true;
            var timerMove = 0;
                var timer2 = 0;
                var timer3 = 0;

            //grid variables. try not to get odd numbers with the horiontalSize and verticalSize
            var CanvasWidth = document.getElementById('gameCanvas').width;
            var Canvasheight = document.getElementById('gameCanvas').height;
            var HA = 15; // made this HA so theres not as much code for the coordinates for the walls.
            var verticalAmount = 10;
            var horizontalsize = (CanvasWidth / HA);
            var verticalsize = (Canvasheight / verticalAmount);

            //players current position and starting position
            var playerXPosition = 1;
            var playerYPosition = 1 * HA;
            
            var playerSpriteHeight = verticalsize;
            var playerSpriteWidth = horizontalsize;
            var frameX = 2;
            var frameY = 0;

            //player movement keys
            const UP_KEY = 87;
            const DOWN_KEY = 83;
            const LEFT_KEY = 65;
            const RIGHT_KEY = 68;
            var upKeyPressed = false;
            var downKeyPressed = false;
            var leftKeyPressed = false;
            var rightKeyPressed = false;
            
            const UP_ARROW_KEY = 38;
            const DOWN_ARROW_KEY = 40;
            const LEFT_ARROW_KEY = 37;
            const RIGHT_ARROW_KEY = 39;
            var hitUpKeyPressed = false;
            var hitDownKeyPressed = false;
            var hitLeftKeyPressed = false;
            var hitRightKeyPressed = false;

            var floorImg = new Image();
            floorImg.src = "img/floor.png";

            var wallImg = new Image();
            wallImg.src = "img/walls_top.png";

            var playerImg = new Image();
            playerImg.src = "img/player.png";
            
            var playerImgMain = new Image();
            playerImgMain.src = "img/main_player.png";

//                        var level = 0;// this is to test spesific levels
            var level = Math.floor((Math.random() * 4));




            // for the wall collision
            var wallCheckY = playerYPosition;
            var wallCheckX = playerXPosition;

            function drawWalls() {

                //                        console.log('run');
                for (i = 1; i < wallsXY[level].length; i++) {
                    //                    colorRect(grid[wallsXY[level][i][0]][0], grid[wallsXY[level][(i)][1]][1], horizontalsize, verticalsize, "rgba(150,1,1,1)");
                    imgLoad(wallImg, grid[wallsXY[level][i][0]][0], grid[wallsXY[level][(i)][1]][1], horizontalsize, verticalsize)
                    //                        console.log(grid[wallsXY[c][i][0]]);
                }



            }

            function keyPressed(evt) { /// had to put multiple so there is no order issue for the movement. helps it stop feeling sticky.
                if (evt.keyCode == UP_ARROW_KEY){
                    hitUpKeyPressed = true;
                }
                if (evt.keyCode == DOWN_ARROW_KEY){
                    hitDownKeyPressed = true;
                }
                if (evt.keyCode == LEFT_ARROW_KEY){
                    hitLeftKeyPressed = true;
                }
                if (evt.keyCode == RIGHT_ARROW_KEY){
                    hitRightKeyPressed = true;
                }
                if (evt.keyCode == UP_KEY && downKeyPressed == false && leftKeyPressed == false && rightKeyPressed == false) {
                    upKeyPressed = true;

                } else {
                    upKeyPressed = false;
                }
                if (evt.keyCode == DOWN_KEY && upKeyPressed == false && leftKeyPressed == false && rightKeyPressed == false) {
                    downKeyPressed = true;

                } else {
                    downKeyPressed = false;
                }
                if (evt.keyCode == RIGHT_KEY && downKeyPressed == false && leftKeyPressed == false && upKeyPressed == false) {
                    rightKeyPressed = true;

                } else {
                    rightKeyPressed = false;
                }
                if (evt.keyCode == LEFT_KEY && downKeyPressed == false && upKeyPressed == false && rightKeyPressed == false) {
                    leftKeyPressed = true;


                } else {
                    leftKeyPressed = false;
                }
                if (evt.keyCode == UP_KEY && downKeyPressed == false && leftKeyPressed == false && rightKeyPressed == false) {
                    upKeyPressed = true;

                } else {
                    upKeyPressed = false;
                }
                if (evt.keyCode == DOWN_KEY && upKeyPressed == false && leftKeyPressed == false && rightKeyPressed == false) {
                    downKeyPressed = true;

                } else {
                    downKeyPressed = false;
                }
                if (evt.keyCode == RIGHT_KEY && downKeyPressed == false && leftKeyPressed == false && upKeyPressed == false) {
                    rightKeyPressed = true;

                } else {
                    rightKeyPressed = false;
                }
                

            }

            function keyReleased(evt) {
                if (evt.keyCode == UP_ARROW_KEY){
                    hitUpKeyPressed = false;
                }
                if (evt.keyCode == DOWN_ARROW_KEY){
                    hitDownKeyPressed = false;
                }
                if (evt.keyCode == LEFT_ARROW_KEY){
                    hitLeftKeyPressed = false;
                }
                if (evt.keyCode == RIGHT_ARROW_KEY){
                    hitRightKeyPressed = false;
                }
                if (evt.keyCode == UP_KEY) {
                    upKeyPressed = false;
                }
                if (evt.keyCode == DOWN_KEY) {
                    downKeyPressed = false;
                }
                if (evt.keyCode == RIGHT_KEY) {
                    rightKeyPressed = false;
                }
                if (evt.keyCode == LEFT_KEY) {
                    leftKeyPressed = false;
                }
               
            }

            function Attack(){
                if(hitUpKeyPressed == true){
                    colorRect(grid[playerXPosition][0], grid[playerYPosition-HA][1], horizontalsize, verticalsize, 'rgb(1,1,1,1)');
    
                    gamerun = true; // lets the mainloop draw the rest of the game
                }
            }
            
            function playerMovement() { // this changes the player's position
                //use + or - 10 to move up or down.
                // use =  or - 1 to mave left to right.
                Attack();
                wallCheckY = playerYPosition; // to remember past Yposition for later
                wallCheckX = playerXPosition; // to remember past Xposition for later

                if (upKeyPressed == true && timerMove >= 5) {
                    playerYPosition -= HA;
                    gamerun = true; // lets the mainloop draw the rest of the game
                    timerMove = 0; // resets the timer for next move
                }
                if (downKeyPressed == true && timerMove >= 5) {
                    playerYPosition += HA;
                    gamerun = true; // lets the mainloop draw the rest of the game
                    timerMove = 0; // resets the timer for next move
                }
                if (leftKeyPressed == true && timerMove >= 5) {
                    playerXPosition -= 1;
                    gamerun = true; // lets the mainloop draw the rest of the game
                    timerMove = 0; // resets the timer for next move
                }
                if (rightKeyPressed == true && timerMove >= 5) {
                    playerXPosition += 1;
                    gamerun = true; // lets the mainloop draw the rest of the game
                    timerMove = 0; // resets the timer for next move
                }

                //                        console.log('run');
                for (i = 1; i < wallsXY[level].length; i++) {
                    if (playerXPosition == wallsXY[level][i][0] && playerYPosition == wallsXY[level][i][1]) { // if the players position is the same as the walls position then it will turn it back to its position befor hand.
                        playerXPosition = wallCheckX; //changes the poition to its previouse state
                        playerYPosition = wallCheckY; //changes the poition to its previouse state
                    }
                }



                //                for (c = 0; c < wallsXY.length; c++) { // this checks all the walls that are in the wallsXY array.
                //                    if (playerXPosition == wallsXY[c][0] && playerYPosition == wallsXY[c][1]) { // if the players position is the same as the walls position then it will turn it back to its position befor hand.
                //                        playerXPosition = wallCheckX; //changes the poition to its previouse state
                //                        playerYPosition = wallCheckY; //changes the poition to its previouse state
                //                    }
                //                }
            }

            //            var playeranimationtimer = 0;
            function drawPlayer() { // draws the player. sort of
                imgLoad(floorImg, grid[wallCheckX][0], grid[wallCheckY][1], horizontalsize, verticalsize);//drwas the background on where the player was
                imgLoad(floorImg, grid[playerXPosition][0], grid[playerYPosition][1], horizontalsize, verticalsize);//drwas the background on where the player will be
                imgLoad(playerImg, grid[wallCheckX][0] + (timer * 10 * (playerXPosition - wallCheckX)), grid[wallCheckY][1] + (timer * 10 * ((playerYPosition - wallCheckY) / HA)), horizontalsize, verticalsize);// draws in bettween pictures of the player. to make it feel smoother
            }

            var grid = []; // the array for the grids

            function creatGrid() { // creates the coordinates for all the blocks
                for (var c = 0; c < verticalAmount; c++) {
                    for (var i = 0; i < HA; i++) {
                        grid.push([(horizontalsize * (i)), (verticalsize * (c))]);
                    }
                }
                console.log(grid); // to see all the coordinates
            }

            function drawGrid() { // draws all the black squares/background
                for (c = 0; c < grid.length; c++) {
                    //                    colorRect(grid[c][0], grid[c][1], horizontalsize, verticalsize, "rgba(1,1,1,1)");
                    imgLoad(floorImg, grid[c][0], grid[c][1], horizontalsize, verticalsize);
                }
            }

            function colorRect(x, y, w, h, c) { // function used to draw simple blocks with colour
                canvasContext.fillStyle = c;
                canvasContext.fillRect(x, y, w, h)
            }

            function imgLoad(src, x, y, w, h) { // function to set up how it gets the data
                canvasContext.drawImage(src, x, y, w, h);
            }
            function imgLoad2(src, x, y, w, h, dx, dy, dWidth, dHeight) { // function to set up how it gets the data
                canvasContext.drawImage(src, x, y, w, h, dx, dy, dWidth, dHeight);
            }
            
            // end of imgLoad func
            // this i wanted to keep just in case I need it
            //                        var colors1 = Math.floor(Math.random()*255);
            //                        var colors2 = Math.floor(Math.random()*255);
            //                        var colors3 = Math.floor(Math.random()*255);
            //                        var finalColor = 'rgba(' + colors1 + ',' + colors2 + ',' + colors3 + ',1)'; 
            //                    grid.push(finalColor)

            // this is all the walls
            var wallsXY = [
                [
                    0,
                    [7, 7 * HA],
                    [8, 7 * HA],
                    [9, 7 * HA],
                    [7, 9 * HA],
                    [7, 8 * HA],
                    [7, 9 * HA],
                    [7, 9 * HA],
                    [8, 9 * HA],
                    [9, 9 * HA],
                    [10, 9 * HA],
                    [10, 9 * HA],
                    [10, 8 * HA],
                    [10, 7 * HA],
                    [3, 8 * HA],
                    [13, 8 * HA]
                ],
                [
                    1, [9, 0 * HA],
                    [10, 0 * HA],
                    [10, 9 * HA],
                    [10, 8 * HA],
                    [10, 7 * HA],
                    [14, 6 * HA],
                    [13, 6 * HA],
                    [9, 7 * HA]
                ]
            ];
            var load = [2]; // this is a substitute for loading all the levels

            function loadLevels() { // creates basic walls like straight lines
                for (i = 0; i < verticalAmount; i++) {
                    wallsXY[0].push([0, i * HA], [HA - 1, i * HA]);
                    wallsXY[1].push([0, i * HA], [HA - 1, i * HA]);
                }
                for (i = 0; i < HA; i++) {
                    wallsXY[0].push([i, 0 * HA], [i, (verticalAmount - 1) * HA]);
                    wallsXY[1].push([i, 0 * HA], [i, (verticalAmount - 1) * HA]);
                }
                //                [i, Math.floor((Math.pow(i, 0.5))) * HA], [i, (Math.floor((Math.pow(i, 0.5))) + 15) * HA]
                //                console.log(load);
                for (i = 0; i < verticalAmount; i++) {
                    load.push([0, i * HA], [HA - 1, i * HA]);
                }
                for (i = 0; i < HA; i++) {
                    load.push([i, 0 * HA], [i, (verticalAmount - 1) * HA]);
                }
                wallsXY.push(load);
                load = [3]; // clears the array for the next level
                for (i = 0; i < HA; i++) {
                    load.push([i, 0 * HA], [i, (verticalAmount - 1) * HA]);
                }
                for (i = 0; i < verticalAmount; i++) {
                    load.push([0, i * HA], [HA - 1, i * HA]);
                }
                for (c = Math.floor((verticalAmount / 4) * 1); c < Math.floor((verticalAmount / 4) * 3 + 1); c++) {

                    for (i = Math.floor(HA / 4); i < Math.floor((HA / 4) * 3 + 1); i++) {
                        load.push([i, c * HA]);
                    }
                }
                wallsXY.push(load);
                load = [4];

            }

        </script>
    </canvas>


</body>

</html>
