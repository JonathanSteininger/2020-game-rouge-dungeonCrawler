<!doctype html>
<html lang="en">

<head>
    <title>JavaScript</title>
</head>

<body>
    <canvas id="gameCanvas" width="600" height="400">
        <script>
            var canvas, canvasContext;
            window.onload = function() {
                canvas = document.getElementById('gameCanvas');
                canvasContext = canvas.getContext('2d');
                document.addEventListener('keydown', keyPressed); // sets the event for the keypressed func 
                document.addEventListener('keyup', keyReleased); // sets the event for the keyreleased func 
                setInterval(
                    mainloop, 1000 / 35); // starts the game loop
                creatGrid(); // creates the grid for the entier game
                loadLevels(); // creates all the levels walls
                levelsetter();
                aiScript();
            }
            var cont69 = 0;
            var testcount = 0;

            function mainloop() {
                if (game && defeat == false) {
                    if (timerMove >= 5 && gamerun == false) { // makes it so theres a clean interuption to your movement
                        playerMovement();
                        if (gamerun == true) {
                            testcount = 0;
                        }
                    } else {
                        timerMove++;
                    }
                    restertTimer();
                    if (gamerun == true) { // makes it so that other things only get drawn if you move. helps for future games. can be removed.
                        let count56 = 0;
                        enemyPositions[level].forEach(Element => {
                            count56++;
                            if (playerXPosition == Element[0] && playerYPosition == Element[1]) { // if the players position is the same as the walls position then it will turn it back to its position befor hand.
                                playerXPosition = wallCheckX; //changes the poition to its previouse state
                                playerYPosition = wallCheckY; //changes the poition to its previouse state
                                if (Element[2] == 1) {
                                    walls[level].push([Element[0], Element[1]]);
                                    imgLoad(floorImg, grid[Element[0]][0], grid[Element[1]][1], horizontalsize, verticalsize);
                                    imgLoad2(wallImg, 0 * horizontalsize, 4 * horizontalsize, horizontalsize, horizontalsize, grid[Element[0]][0], grid[Element[1]][1], horizontalsize, verticalsize);
                                } else {
                                    imgLoad(floorImg, grid[Element[0]][0], grid[Element[1]][1], horizontalsize, verticalsize);
                                }
                                delete enemyPositions[level][count56 - 1];
                                enemyPositions[level] = enemyPositions[level].filter(item => item !== undefined);
                                delete closedList[count56 - 1];
                                closedList = closedList.filter(item => item !== undefined);
                                delete routChoose[count56 - 1];
                                routChoose = routChoose.filter(item => item !== undefined);
                                moveFrame += 4;
                            }
                        });

                        if (testcount == 0) {
                            aiScript();
                            enemiecheck();
                        }

                        runAI();
                        drawPlayer();
                        testcount++;
                        if (testcount >= 5) {
                            gamerun = false;
                            if (playerXPosition >= HA - 1) {
                                goto();
                            }
                        }

                    } else {
                        if (timer2 >= 2) {
                            imgLoad(floorImg, grid[playerXPosition][0], grid[playerYPosition][1], horizontalsize, verticalsize);
                            imgLoad2(playerImgMain, timer * 40, 0, playerSpriteWidth, playerSpriteHeight, grid[playerXPosition][0], grid[playerYPosition][1], horizontalsize, verticalsize);
                            if (timer < 9) {
                                timer++;
                            } else {
                                timer = 0;
                            }
                            enemyPositions[level].forEach(Element => {
                                if (Element[2] == 0) {
                                    imgLoad(floorImg, grid[Element[0]][0], grid[Element[1]][1], horizontalsize, verticalsize);
                                    imgLoad2(enemyWall0, Element[3] * 40, 0, playerSpriteWidth, playerSpriteHeight, (grid[Element[0]][0]), (grid[Element[1]][1]), horizontalsize, verticalsize);
                                } else if (Element[2] == 1) {
                                    imgLoad(floorImg, grid[Element[0]][0], grid[Element[1]][1], horizontalsize, verticalsize);
                                    imgLoad2(enemyWall, Element[3] * 40, 0, playerSpriteWidth, playerSpriteHeight, (grid[Element[0]][0]), (grid[Element[1]][1]), horizontalsize, verticalsize);
                                }
                                if (Element[3] < 9) {
                                    Element[3]++;
                                } else {
                                    Element[3] = 0;
                                }
                            });
                            timer2 = 0;
                        } else {
                            timer2++;
                        }
                    }
                    complitionCheck();
                } else {
                    if (onetick == true) {
                        imgLoad(floorImg, grid[wallCheckX][0], grid[wallCheckY][1], horizontalsize, verticalsize);
                        colorRect(0, 0, CanvasWidth, Canvasheight, 'rgb(50,1,1,0.7)');
                        onetick = false;
                    }
                    if (timer2 >= 2) {
                        imgLoad(floorImg, grid[playerXPosition][0], grid[playerYPosition][1], horizontalsize, verticalsize);
                        imgLoad2(playerImgMain, timerEnd * 40, 9 * 40, playerSpriteWidth, playerSpriteHeight, grid[playerXPosition][0], grid[playerYPosition][1], horizontalsize, verticalsize);
                        colorRect(grid[playerXPosition][0], grid[playerYPosition][1], horizontalsize, horizontalsize, 'rgb(50,1,1,0.7)');
                        colorRect(CanvasWidth / 4, Canvasheight / 4, CanvasWidth / 2, Canvasheight / 2, 'rgb(1,1,1,1)');
                        drawText(CanvasWidth / 2, (Canvasheight / 2) - 20, "dead", "30px Arial", "rgb(255,255,255,1)", "center");
                        drawText(CanvasWidth / 2, Canvasheight / 2 + 50, "Hold R to restart", "30px Arial", "rgb(255,255,255,1)", "center");
                        timerEnd = Math.floor(Math.random() * 10);
                    } else {
                        timer2++;
                    }
                    restertTimer();
                }
            }
            //mainloop timers and ifs
            var timerEnd = 0;
            var gamerun = false;
            var movement = false;
            var timerMove = 0;
            var timer = 0;
            var timer2 = 0;
            var timer3 = 0;
            var game = true;
            var onetick = true;

            //grid variables. try not to get odd numbers with the horiontalSize and verticalSize
            var CanvasWidth = document.getElementById('gameCanvas').width;
            var Canvasheight = document.getElementById('gameCanvas').height;
            var HA = 15; // made this HA so theres not as much code for the coordinates for the walls.
            var verticalAmount = 10;
            var horizontalsize = (CanvasWidth / HA);
            var verticalsize = (Canvasheight / verticalAmount);

            //players current position and starting position
            var playerXPosition = 3;
            var playerYPosition = 8 * HA;

            var playerSpriteHeight = verticalsize;
            var playerSpriteWidth = horizontalsize;
            var frameX = 2;
            var moveFrame = 1;

            //player movement keys
            const LEFT_ARROW_KEY = 37;
            const RIGHT_ARROW_KEY = 39;
            const UP_ARROW_KEY = 38;
            const DOWN_ARROW_KEY = 40;
            const LEFT_KEY = 65;
            const RIGHT_KEY = 68;
            const UP_KEY = 87;
            const DOWN_KEY = 83;
            var leftKeyPressed = false;
            var rightKeyPressed = false;
            var upKeyPressed = false;
            var downKeyPressed = false;

            const R_KEY = 82;
            var rKeyPressed = false;

            //images
            var floorImg = new Image();
            floorImg.src = "img/floor.png";
            var wallImg = new Image();
            wallImg.src = "img/walls_v4.png";
            var playerImg = new Image();
            playerImg.src = "img/player.png";
            var playerImgMain = new Image();
            playerImgMain.src = "img/main_player.png";
            var enemyWall = new Image();
            enemyWall.src = "img/enemy_sheet1.png";
            var enemyWall0 = new Image();
            enemyWall0.src = "img/enemy_sheet0.png";
            // for the wall collision
            var wallCheckY = playerYPosition;
            var wallCheckX = playerXPosition;

            var restartTime = timerLength;
            var timerLength = 35;

            function restertTimer() {
                if (rKeyPressed == true) {
                    restartTime--;
                }
                if (restartTime <= 0) {
                    retry();
                    restartTime = timerLength;
                }
            }




            function complitionCheck() {
                if (enemyPositions[level].length <= 0) {
                    for (let b = 0; b < walls[level].length; b++)
                        if (walls[level][b][4] == 'door') {
                            walls[level][b][2] = 2;
                            imgLoad2(wallImg, walls[level][b][2] * horizontalsize, walls[level][b][3] * horizontalsize, horizontalsize, horizontalsize, grid[walls[level][b][0]][0], grid[walls[level][(b)][1]][1], horizontalsize, verticalsize);
                        }
                }
            }


            function drawWalls() {
                for (let i = 0; i < walls[level].length; i++) {
                    imgLoad2(wallImg, walls[level][i][2] * horizontalsize, walls[level][i][3] * horizontalsize, horizontalsize, horizontalsize, grid[walls[level][i][0]][0], grid[walls[level][(i)][1]][1], horizontalsize, verticalsize);
                    for (let pp = 0; pp < walls[level][i][5].length; pp++) {
                        imgLoad2(wallImg, walls[level][i][5][pp] * horizontalsize, walls[level][i][3] * horizontalsize, horizontalsize, horizontalsize, grid[walls[level][i][0]][0], grid[walls[level][(i)][1]][1], horizontalsize, verticalsize);

                    }
                }
            }

            function levelsetter() {
                levelloadTimer = 20;
                drawGrid(); //darws background once
                walls = JSON.parse(JSON.stringify(wallsStartPoss));
                drawWalls(); //draws walls onsce
                playerXPosition = playerStartPos[level][0];
                playerYPosition = playerStartPos[level][1];
                enemyPositions = JSON.parse(JSON.stringify(enemyStartPos));
                enemyPositions[level].forEach(Element => {
                    if (Element[2] == 0) {
                        imgLoad(floorImg, grid[Element[0]][0], grid[Element[1]][1], horizontalsize, verticalsize);
                        imgLoad2(enemyWall0, Element[3] * 40, 0 * 40, playerSpriteWidth, playerSpriteHeight, grid[Element[0]][0], grid[Element[1]][1], horizontalsize, verticalsize);
                    } else if (Element[2] == 1) {
                        imgLoad(floorImg, grid[Element[0]][0], grid[Element[1]][1], horizontalsize, verticalsize);
                        imgLoad2(enemyWall, Element[3] * 40, 0 * 40, playerSpriteWidth, playerSpriteHeight, grid[Element[0]][0], grid[Element[1]][1], horizontalsize, verticalsize);
                    }
                });
                aiScript();
            }

            var defeat = false;

            function death() {
                defeat = true;
            }
            var enemyPositions;

            var routeCount = 0;
            var elementCounterRunAI = 0;

            function goto() {
                level++;
                levelsetter();
            }

            function enemiecheck() {
                enemyPositions[level].forEach(Element => {
                    Element[5] = true;
                });
                enemyPositions[level].forEach(Element => {
                    for (let hh = 0; hh < enemyPositions[level].length; hh++) {
                        for (let ff = 0; ff < enemyPositions[level].length; ff++) {
                            if (closedList[hh][routChoose[hh]][1][0] == closedList[ff][routChoose[ff]][1][0] && closedList[hh][routChoose[hh]][1][1] == closedList[ff][routChoose[ff]][1][1] && hh !== ff && ff < (hh)) {
                                enemyPositions[level][hh][5] = false;
                            }
                            if (closedList[hh][routChoose[hh]][1][0] == enemyPositions[level][ff][0] && closedList[hh][routChoose[hh]][1][1] * HA == enemyPositions[level][ff][1] && enemyPositions[level][ff][5] == false && hh !== ff) {
                                enemyPositions[level][hh][5] = false;
                            }
                        }
                    }
                });
            }

            function runAI() {
                elementCounterRunAI = 0;
                enemyPositions[level].forEach(Element => {
                    elementCounterRunAI++;
                    let aimove = true;
                    if (closedList[elementCounterRunAI - 1][routChoose[elementCounterRunAI - 1]][1][0] == playerXPosition && closedList[elementCounterRunAI - 1][routChoose[elementCounterRunAI - 1]][1][1] == (playerYPosition / HA)) {
                        death();
                    } else {
                        for (let hh = 0; hh < enemyPositions[level].length; hh++) {
                            if (closedList[elementCounterRunAI - 1][routChoose[elementCounterRunAI - 1]][1][0] == closedList[hh][routChoose[hh]][1][0] && closedList[elementCounterRunAI - 1][routChoose[elementCounterRunAI - 1]][1][1] == closedList[hh][routChoose[hh]][1][1] && elementCounterRunAI - 1 !== hh && hh < (elementCounterRunAI - 1)) {
                                aimove = false;
                                Element[5] = false;
                            }
                            if (closedList[elementCounterRunAI - 1][routChoose[elementCounterRunAI - 1]][1][0] * HA == enemyPositions[level][hh][0] && closedList[elementCounterRunAI - 1][routChoose[elementCounterRunAI - 1]][1][1] * HA == enemyPositions[level][hh][1] && enemyPositions[level][hh][5] == false && elementCounterRunAI - 1 !== hh) {
                                aimove = false;
                                Element[5] = false;
                            }
                        }
                        if (aimove == true && Element[5] == true) {
                            if (testcount == 0) {
                                Element[4][0] = JSON.parse(JSON.stringify(Element[0])); //variable to contain its past X position
                                Element[4][1] = JSON.parse(JSON.stringify(Element[1])); //variable to contain its past Y position
                                Element[0] = JSON.parse(JSON.stringify(closedList[elementCounterRunAI - 1][routChoose[elementCounterRunAI - 1]][routeCount][0])); //changes its X position according to the rout it found with test55();
                                Element[1] = JSON.parse(JSON.stringify(closedList[elementCounterRunAI - 1][routChoose[elementCounterRunAI - 1]][routeCount][1] * HA)); //changes its Y position according to the rout it found with test55();
                            }
                            let back = true;
                            let forward = true;
                            for (let cc = 0; cc < enemyPositions[level].length; cc++) {
                                if (Element[4][0] == enemyPositions[level][cc][0] && Element[4][1] == enemyPositions[level][cc][1] && cc !== elementCounterRunAI - 1 && elementCounterRunAI - 1 > cc) {
                                    back = false;
                                }
                                if (Element[0] == enemyPositions[level][cc][4][0] && Element[1] == enemyPositions[level][cc][4][1] && cc !== elementCounterRunAI - 1 && elementCounterRunAI - 1 > cc) {
                                    forward = false;
                                }
                            }
                            if (back == true) {
                                imgLoad(floorImg, grid[Element[4][0]][0], grid[Element[4][1]][1], horizontalsize, verticalsize);
                            }
                            if (forward == true) {
                                imgLoad(floorImg, grid[Element[0]][0], grid[Element[1]][1], horizontalsize, verticalsize);
                            }


                            if (Element[2] == 0) {
                                imgLoad2(enemyWall0, testcount * 40, 1 * 40, playerSpriteWidth, playerSpriteHeight, (grid[closedList[elementCounterRunAI - 1][routChoose[elementCounterRunAI - 1]][0][0]][0] + (testcount * 10 * (closedList[elementCounterRunAI - 1][routChoose[elementCounterRunAI - 1]][1][0] - closedList[elementCounterRunAI - 1][routChoose[elementCounterRunAI - 1]][0][0]))), (grid[closedList[elementCounterRunAI - 1][routChoose[elementCounterRunAI - 1]][0][1] * HA][1] + (testcount * 10 * (closedList[elementCounterRunAI - 1][routChoose[elementCounterRunAI - 1]][1][1] - closedList[elementCounterRunAI - 1][routChoose[elementCounterRunAI - 1]][0][1]))), horizontalsize, verticalsize);
                            } else if (Element[2] == 1) {
                                //                                imgLoad(floorImg, grid[Element[0]][0], grid[Element[1]][1], horizontalsize, verticalsize);
                                imgLoad2(enemyWall, testcount * 40, 1 * 40, playerSpriteWidth, playerSpriteHeight, (grid[closedList[elementCounterRunAI - 1][routChoose[elementCounterRunAI - 1]][0][0]][0] + (testcount * 10 * (closedList[elementCounterRunAI - 1][routChoose[elementCounterRunAI - 1]][1][0] - closedList[elementCounterRunAI - 1][routChoose[elementCounterRunAI - 1]][0][0]))), (grid[closedList[elementCounterRunAI - 1][routChoose[elementCounterRunAI - 1]][0][1] * HA][1] + (testcount * 10 * (closedList[elementCounterRunAI - 1][routChoose[elementCounterRunAI - 1]][1][1] - closedList[elementCounterRunAI - 1][routChoose[elementCounterRunAI - 1]][0][1]))), horizontalsize, verticalsize);

                            }
                        } else {
                            if (Element[2] == 0) {
                                imgLoad(floorImg, grid[Element[0]][0], grid[Element[1]][1], horizontalsize, verticalsize);
                                imgLoad2(enemyWall0, Element[3] * 40, 0 * 40, playerSpriteWidth, playerSpriteHeight, (grid[Element[0]][0]), (grid[Element[1]][1]), horizontalsize, verticalsize);
                            } else if (Element[2] == 1) {
                                imgLoad(floorImg, grid[Element[0]][0], grid[Element[1]][1], horizontalsize, verticalsize);
                                imgLoad2(enemyWall, Element[3] * 40, 0 * 40, playerSpriteWidth, playerSpriteHeight, (grid[Element[0]][0]), (grid[Element[1]][1]), horizontalsize, verticalsize);
                            }
                        }
                    }
                });
                routeCount++;
            }
            var routChoose = [];
            var closedList = [
                []
            ];

            function aiScript() { //func start
                routChoose = [];
                let elementCount = 0;
                closedList = []; //[[[[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2]],[[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2]]],[[[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2]],[[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2]]]]
                for (let kk = 0; kk < enemyPositions[level].length; kk++) {
                    closedList.push([]);
                }
                routeCount = 1;
                enemyPositions[level].forEach(Element => { //foreach start
                    elementCount++;
                    let failsafe = 0;
                    var checkArray = [
                        [
                            [Element[0], Element[1] / HA]
                        ]
                    ]
                    var openList = [
                        [
                            [Element[0], Element[1] / HA]
                        ]
                    ];
                    while (closedList[elementCount - 1].length <= 0 && failsafe < 90) { //while start
                        let stepOpenList = openList.length; // used to remember which to delet for the open list at the end.
                        failsafe++;
                        for (let i = 0; i < stepOpenList; i++) { //loop1 start
                            let left = [];
                            let right = [];
                            let up = [];
                            let down = [];
                            let b = openList[i][openList[i].length - 1]; //[13,1]//[9,1]
                            let testLeft = true;
                            let testRight = true;
                            let testUp = true;
                            let testDown = true;
                            for (let oo = 0; oo < walls[level].length; oo++) { //loop2 start
                                if (b[0] - 1 == 0) {
                                    testLeft = false;
                                } else if (b[0] - 1 == walls[level][oo][0] && b[1] == (walls[level][oo][1] / HA)) {
                                    testLeft = false;
                                }
                                if (b[0] + 1 == HA) {
                                    testRight = false;

                                } else if (b[0] + 1 == walls[level][oo][0] && b[1] == (walls[level][oo][1] / HA)) {
                                    testRight = false;
                                }
                                if (b[1] - 1 <= 0) {
                                    testUp = false;

                                } else if (b[0] == walls[level][oo][0] && b[1] - 1 == (walls[level][oo][1] / HA)) {
                                    testUp = false;
                                }
                                if (b[1] + 1 >= verticalAmount) {
                                    testDown = false;

                                } else if (b[0] == walls[level][oo][0] && b[1] + 1 == (walls[level][oo][1] / HA)) {
                                    testDown = false;
                                }
                            } //loop2 end
                            if (testLeft == true) { //left
                                Object.assign(left, openList[i])
                                left.push([b[0] - 1, b[1]]);
                            }
                            if (testRight == true) { //right
                                Object.assign(right, openList[i]);
                                right.push([b[0] + 1, b[1]]);
                            }
                            if (testUp == true) { //up
                                Object.assign(up, openList[i]);
                                up.push([b[0], b[1] - 1]);
                            }
                            if (testDown == true) { //down
                                Object.assign(down, openList[i]);
                                down.push([b[0], b[1] + 1]); // [[10,1],[11,1],[12,1],[13,1],[b[0],b[1] + 1]]
                            }
                            let leftfalse = false;
                            let rightfalse = false;
                            let upfalse = false;
                            let downfalse = false;
                            for (let l = 0; l < openList.length; l++) { //loop3 start
                                for (let c = 0; c < openList[l].length; c++) { //loop4 start
                                    if (testLeft == false) {
                                        leftfalse = true;
                                    } else if (left[left.length - 1][0] == openList[l][c][0] && left[left.length - 1][1] == openList[l][c][1]) {
                                        leftfalse = true;
                                    }
                                    if (testRight == false) {
                                        rightfalse = true;
                                    } else if (right[right.length - 1][0] == openList[l][c][0] && right[right.length - 1][1] == openList[l][c][1]) {
                                        rightfalse = true;
                                    }
                                    if (testUp == false) {
                                        upfalse = true;
                                    } else if (up[up.length - 1][0] == openList[l][c][0] && up[up.length - 1][1] == openList[l][c][1]) {
                                        upfalse = true;
                                    }
                                    if (testDown == false) {
                                        downfalse = true;
                                    } else if (down[down.length - 1][0] == openList[l][c][0] && down[down.length - 1][1] == openList[l][c][1]) {
                                        downfalse = true;
                                    }
                                } //loop4 end
                            } //loop3 end
                            for (let l = 0; l < checkArray.length; l++) { //loop5 start
                                for (let c = 0; c < checkArray[l].length; c++) { //loop6 start
                                    if (testLeft == false) {
                                        leftfalse = true;
                                    } else if (left[left.length - 1][0] == checkArray[l][c][0] && left[left.length - 1][1] == checkArray[l][c][1]) {
                                        leftfalse = true;
                                    }
                                    if (testRight == false) {
                                        rightfalse = true;
                                    } else if (right[right.length - 1][0] == checkArray[l][c][0] && right[right.length - 1][1] == checkArray[l][c][1]) {
                                        rightfalse = true;
                                    }
                                    if (testUp == false) {
                                        upfalse = true;
                                    } else if (up[up.length - 1][0] == checkArray[l][c][0] && up[up.length - 1][1] == checkArray[l][c][1]) {
                                        upfalse = true;
                                    }
                                    if (testDown == false) {
                                        downfalse = true;
                                    } else if (down[down.length - 1][0] == checkArray[l][c][0] && down[down.length - 1][1] == checkArray[l][c][1]) {
                                        downfalse = true;
                                    }
                                } //loop6 end
                            } //loop5 end
                            if (leftfalse == false) {
                                if (left[left.length - 1][0] == playerXPosition && left[left.length - 1][1] == playerYPosition / HA) {
                                    closedList[elementCount - 1].push(left);
                                } else {
                                    openList.push(left);
                                }
                            }
                            if (rightfalse == false) {
                                if (right[right.length - 1][0] == playerXPosition && right[right.length - 1][1] == playerYPosition / HA) {
                                    closedList[elementCount - 1].push(right);
                                } else {
                                    openList.push(right);
                                }
                            }
                            if (upfalse == false) {
                                if (up[up.length - 1][0] == playerXPosition && up[up.length - 1][1] == playerYPosition / HA) {
                                    closedList[elementCount - 1].push(up);
                                } else {
                                    openList.push(up);
                                }
                            }
                            if (downfalse == false) {
                                if (down[down.length - 1][0] == playerXPosition && down[down.length - 1][1] == playerYPosition / HA) {
                                    closedList[elementCount - 1].push(down);
                                } else {
                                    openList.push(down);
                                }
                            }
                        } //loop1 end
                        for (let u = 0; u < stepOpenList; u++) {
                            checkArray.push(openList[u]);
                            delete openList[u];
                        }
                        openList = openList.filter(item => item !== undefined);
                    } //while end
                    routChoose.push(Math.floor(Math.random() * closedList[elementCount - 1].length));
                }); //foreach end
            } //func end

            function keyPressed(evt) { /// had to put multiple so there is no order issue for the movement. helps it stop feeling sticky.
                if (evt.keyCode == UP_KEY && restartTime == timerLength || evt.keyCode == UP_ARROW_KEY && restartTime == timerLength) {
                    upKeyPressed = true;
                }
                if (evt.keyCode == DOWN_KEY && restartTime == timerLength || evt.keyCode == DOWN_ARROW_KEY && restartTime == timerLength) {
                    downKeyPressed = true;
                }
                if (evt.keyCode == RIGHT_KEY && restartTime == timerLength || evt.keyCode == RIGHT_ARROW_KEY && restartTime == timerLength) {
                    rightKeyPressed = true;
                }
                if (evt.keyCode == LEFT_KEY && restartTime == timerLength || evt.keyCode == LEFT_ARROW_KEY && restartTime == timerLength) {
                    leftKeyPressed = true;
                }
                if (evt.keyCode == R_KEY) {
                    rKeyPressed = true;
                }
            }

            function keyReleased(evt) {
                if (evt.keyCode == UP_KEY || evt.keyCode == UP_ARROW_KEY) {
                    upKeyPressed = false;
                }
                if (evt.keyCode == DOWN_KEY || evt.keyCode == DOWN_ARROW_KEY) {
                    downKeyPressed = false;
                }
                if (evt.keyCode == RIGHT_KEY || evt.keyCode == RIGHT_ARROW_KEY) {
                    rightKeyPressed = false;
                }
                if (evt.keyCode == LEFT_KEY || evt.keyCode == LEFT_ARROW_KEY) {
                    leftKeyPressed = false;
                }
                if (evt.keyCode == R_KEY) {
                    rKeyPressed = false;
                    restartTime = timerLength;
                }
            }

            function drawPlayer() { // draws the player. sort of
                let past = true;
                let future = true;
                for (let hh = 0; hh < enemyPositions[level].length; hh++) {
                    if (wallCheckX == enemyPositions[level][hh][0] && wallCheckY == enemyPositions[level][hh][1]) {
                        past = false;
                    }
                }
                if (playerXPosition >= HA) {
                    future = false;
                }
                if (past == true) {
                    imgLoad(floorImg, grid[wallCheckX][0], grid[wallCheckY][1], horizontalsize, verticalsize); //draws the background on where the player was
                }
                if (future == true) {
                    imgLoad(floorImg, grid[playerXPosition][0], grid[playerYPosition][1], horizontalsize, verticalsize); //draws the background on where the player will be
                }
                imgLoad2(playerImgMain, testcount * 40, moveFrame * 40, playerSpriteWidth, playerSpriteHeight, grid[wallCheckX][0] + (testcount * 10 * (playerXPosition - wallCheckX)), grid[wallCheckY][1] + (testcount * 10 * ((playerYPosition - wallCheckY) / HA)), horizontalsize, verticalsize); // draws in bettween pictures of the player. to make it feel smoother
            }
            var levelloadTimer = 0;

            function playerMovement() { // this changes the player's position
                //use + or - 10 to move up or down.
                // use =  or - 1 to mave left to right.
                if (levelloadTimer > 0) {
                    levelloadTimer--;
                }
                if (levelloadTimer <= 0) {
                    wallCheckY = playerYPosition; // to remember past Yposition
                    wallCheckX = playerXPosition; // to remember past Xposition

                    if (upKeyPressed == true && timerMove >= 5) {
                        playerYPosition -= HA;
                        gamerun = true; // lets the mainloop draw the rest of the game
                        timerMove = 0; // resets the timer for next move
                        moveFrame = 3;
                    }
                    if (downKeyPressed == true && timerMove >= 5) {
                        playerYPosition += HA;
                        gamerun = true; // lets the mainloop draw the rest of the game
                        timerMove = 0; // resets the timer for next move
                        moveFrame = 4;
                    }
                    if (leftKeyPressed == true && timerMove >= 5) {
                        playerXPosition -= 1;
                        gamerun = true; // lets the mainloop draw the rest of the game
                        timerMove = 0; // resets the timer for next move
                        moveFrame = 2;
                    }
                    if (rightKeyPressed == true && timerMove >= 5) {
                        playerXPosition += 1;
                        gamerun = true; // lets the mainloop draw the rest of the game
                        timerMove = 0; // resets the timer for next move
                        moveFrame = 1; //sets which movement animation to use
                    }
                    for (let i = 0; i < walls[level].length; i++) {
                        if (playerXPosition == walls[level][i][0] && playerYPosition == walls[level][i][1] && walls[level][i][2] !== 2) { // if the players position is the same as the walls position then it will turn it back to its position befor hand.
                            playerXPosition = wallCheckX; //changes the poition to its previouse state
                            playerYPosition = wallCheckY; //changes the poition to its previouse state
                            gamerun = false;
                        }
                    }
                }
            }

            var grid = []; // the array for the grids
            function creatGrid() { // creates the coordinates for all the blocks
                for (let c = 0; c < verticalAmount; c++) {
                    for (let i = 0; i < HA; i++) {
                        grid.push([(horizontalsize * (i)), (verticalsize * (c))]);
                    }
                }
            }

            function drawGrid() { // draws all the black squares/background
                for (let c = 0; c < grid.length; c++) {
                    imgLoad(floorImg, grid[c][0], grid[c][1], horizontalsize, verticalsize);
                }
            }

            function difference(a, b) { // checks the difference in values
                return Math.abs(a - b);
            }

            function colorRect(x, y, w, h, c) { // function used to draw simple blocks with colour
                canvasContext.fillStyle = c;
                canvasContext.fillRect(x, y, w, h)
            }

            function drawText(x, y, t, f, c, d) {
                canvasContext.fillStyle = c;
                canvasContext.textAlign = d;
                canvasContext.font = f;
                canvasContext.fillText(t, x, y);
            }

            function imgLoad(src, x, y, w, h) { // function to draw an image
                canvasContext.drawImage(src, x, y, w, h);
            } // end of imgLoad func

            function imgLoad2(src, x, y, w, h, dx, dy, dWidth, dHeight) { // function to draw a sprite sheet
                canvasContext.drawImage(src, x, y, w, h, dx, dy, dWidth, dHeight);
            } // end of imgLoad2 func

            // this i wanted to keep just in case I need it
            //                        var colors1 = Math.floor(Math.random()*255);
            //                        var colors2 = Math.floor(Math.random()*255);
            //                        var colors3 = Math.floor(Math.random()*255);
            //                        var finalColor = 'rgba(' + colors1 + ',' + colors2 + ',' + colors3 + ',1)'; 
            //                    grid.push(finalColor)
            const enemyStartPos = [
                [ //0
                    [8, 5 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],

                ],
                [ //1
                    [8, 5 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [8, 4 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],

                ],
                [ //2
                    [9, 4 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [9, 5 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [9, 6 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [6, 4 * HA, 1, Math.floor(Math.random() * 10), [0, 0], true],
                    [6, 5 * HA, 1, Math.floor(Math.random() * 10), [0, 0], true],

                ],
                [ //3
                    [7, 1 * HA, 1, Math.floor(Math.random() * 10), [0, 0], true], //[x, y, enemy type, animation start timer, [pset x pos, past y pos], movement true/false]
                    [7, 7 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [9, 1 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true]
                ],
                [ //brsd//4
                    [1, 8 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [1, 7 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [2, 8 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [5, 4 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [13, 1 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [13, 2 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [13, 7 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [13, 8 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [12, 8 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [12, 7 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [11, 8 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [3, 3 * HA, 1, Math.floor(Math.random() * 10), [0, 0], true],
                ],
                [ //5
                    [4, 5 * HA, 1, Math.floor(Math.random() * 10), [0, 0], true],
                    [4, 4 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [5, 5 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [9, 5 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [10, 5 * HA, 1, Math.floor(Math.random() * 10), [0, 0], true],
                    [11, 5 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [10, 4 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [7, 8 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [12, 1 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                    [9, 1 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],

                ],
                [ //6
                    [8, 1 * HA, 0, Math.floor(Math.random() * 10), [0, 0], true],
                ],
            ];


            function retry() {
                defeat = false;
                gamerun = false;
                onetick = true;
                levelsetter();

            }



            var playerStartPos = [
                [1, 5 * HA], //0
                [1, 5 * HA], //1
                [1, 5 * HA], //2
                [3, 8 * HA], //3
                [3, 8 * HA], //4
                [1, 5 * HA], //5
                [1, 5 * HA], //6
            ];

            var level = 0;
            //            var level = Math.floor((Math.random() * 6));
            // this is all the walls
            var wallsStartPoss = [
                [ //0
                    [1, 6 * HA, 0, 4, 'pit', []],
                    [2, 6 * HA, 0, 4, 'pit', []],
                    [3, 6 * HA, 0, 4, 'pit', []],
                    [4, 6 * HA, 0, 4, 'pit', []],
                    [5, 6 * HA, 0, 4, 'pit', []],
                    [6, 6 * HA, 0, 4, 'pit', []],
                    [7, 6 * HA, 0, 4, 'pit', []],
                    [8, 6 * HA, 0, 4, 'pit', []],
                    [9, 6 * HA, 0, 4, 'pit', []],
                    [10, 6 * HA, 0, 4, 'pit', []],
                    [11, 6 * HA, 0, 4, 'pit', []],
                    [12, 6 * HA, 0, 4, 'pit', []],
                    [13, 6 * HA, 0, 4, 'pit', []],
                    [1, 4 * HA, 0, 4, 'pit', []],
                    [2, 4 * HA, 0, 4, 'pit', []],
                    [3, 4 * HA, 0, 4, 'pit', []],
                    [4, 4 * HA, 0, 4, 'pit', []],
                    [5, 4 * HA, 0, 4, 'pit', []],
                    [6, 4 * HA, 0, 4, 'pit', []],
                    [7, 4 * HA, 0, 4, 'pit', []],
                    [8, 4 * HA, 0, 4, 'pit', []],
                    [9, 4 * HA, 0, 4, 'pit', []],
                    [10, 4 * HA, 0, 4, 'pit', []],
                    [11, 4 * HA, 0, 4, 'pit', []],
                    [12, 4 * HA, 0, 4, 'pit', []],
                    [13, 4 * HA, 0, 4, 'pit', []],
                    [14, 4 * HA, 0, 1, 'wall', []],
                    [14, 5 * HA, 1, 1, 'door', []],
                ],
                [ //1
                    [1, 6 * HA, 0, 4, 'pit', []],
                    [2, 6 * HA, 0, 4, 'pit', []],
                    [3, 6 * HA, 0, 4, 'pit', []],
                    [4, 6 * HA, 0, 4, 'pit', []],
                    [5, 6 * HA, 0, 4, 'pit', []],
                    [6, 6 * HA, 0, 4, 'pit', []],
                    [7, 6 * HA, 0, 4, 'pit', []],
                    [8, 6 * HA, 0, 4, 'pit', []],
                    [9, 6 * HA, 0, 4, 'pit', []],
                    [10, 6 * HA, 0, 4, 'pit', []],
                    [11, 6 * HA, 0, 4, 'pit', []],
                    [12, 6 * HA, 0, 4, 'pit', []],
                    [13, 6 * HA, 0, 4, 'pit', []],
                    [1, 3 * HA, 0, 4, 'pit', []],
                    [2, 3 * HA, 0, 4, 'pit', []],
                    [3, 3 * HA, 0, 4, 'pit', []],
                    [4, 3 * HA, 0, 4, 'pit', []],
                    [5, 3 * HA, 0, 4, 'pit', []],
                    [6, 3 * HA, 0, 4, 'pit', []],
                    [7, 3 * HA, 0, 4, 'pit', []],
                    [8, 3 * HA, 0, 4, 'pit', []],
                    [9, 3 * HA, 0, 4, 'pit', []],
                    [10, 3 * HA, 0, 4, 'pit', []],
                    [11, 3 * HA, 0, 4, 'pit', []],
                    [12, 3 * HA, 0, 4, 'pit', []],
                    [13, 3 * HA, 0, 4, 'pit', []],
                    [14, 4 * HA, 1, 1, 'door', []],
                    [14, 5 * HA, 1, 1, 'door', []],
                ],
                [ //2
                    [1, 7 * HA, 0, 4, 'pit', []],
                    [2, 7 * HA, 0, 4, 'pit', []],
                    [3, 7 * HA, 0, 4, 'pit', []],
                    [4, 7 * HA, 0, 4, 'pit', []],
                    [5, 7 * HA, 0, 4, 'pit', []],
                    [6, 7 * HA, 0, 4, 'pit', []],
                    [7, 7 * HA, 0, 4, 'pit', []],
                    [8, 7 * HA, 0, 4, 'pit', []],
                    [9, 7 * HA, 0, 4, 'pit', []],
                    [10, 7 * HA, 0, 4, 'pit', []],
                    [11, 7 * HA, 0, 4, 'pit', []],
                    [12, 7 * HA, 0, 4, 'pit', []],
                    [13, 7 * HA, 0, 4, 'pit', []],
                    [1, 2 * HA, 0, 4, 'pit', []],
                    [2, 2 * HA, 0, 4, 'pit', []],
                    [3, 2 * HA, 0, 4, 'pit', []],
                    [4, 2 * HA, 0, 4, 'pit', []],
                    [5, 2 * HA, 0, 4, 'pit', []],
                    [6, 2 * HA, 0, 4, 'pit', []],
                    [7, 2 * HA, 0, 4, 'pit', []],
                    [8, 2 * HA, 0, 4, 'pit', []],
                    [9, 2 * HA, 0, 4, 'pit', []],
                    [10, 2 * HA, 0, 4, 'pit', []],
                    [11, 2 * HA, 0, 4, 'pit', []],
                    [12, 2 * HA, 0, 4, 'pit', []],
                    [13, 2 * HA, 0, 4, 'pit', []],
                    [4, 3 * HA, 0, 4, 'pit', []],
                    [5, 3 * HA, 0, 4, 'pit', []],
                    [6, 3 * HA, 0, 4, 'pit', []],
                    [7, 3 * HA, 0, 4, 'pit', []],
                    [8, 3 * HA, 0, 4, 'pit', []],
                    [9, 3 * HA, 0, 4, 'pit', []],
                    [10, 3 * HA, 0, 4, 'pit', []],
                    [14, 4 * HA, 1, 1, 'door', []],
                    [14, 5 * HA, 1, 1, 'door', []],
                ],
                [ //3
                    [2, 2 * HA, 0, 4, 'pit', []],
                    [3, 2 * HA, 0, 4, 'pit', []],
                    [4, 2 * HA, 0, 4, 'pit', []],
                    [5, 2 * HA, 0, 4, 'pit', []],
                    [6, 2 * HA, 0, 4, 'pit', []],
                    [7, 2 * HA, 0, 4, 'pit', []],
                    [9, 2 * HA, 0, 4, 'pit', []],
                    [10, 2 * HA, 0, 4, 'pit', []],
                    [11, 2 * HA, 0, 4, 'pit', []],
                    [12, 2 * HA, 0, 4, 'pit', []],
                    [12, 3 * HA, 0, 4, 'pit', []],
                    [12, 4 * HA, 0, 4, 'pit', []],
                    [12, 5 * HA, 0, 4, 'pit', []],
                    [12, 6 * HA, 0, 4, 'pit', []],
                    [12, 7 * HA, 0, 4, 'pit', []],
                    [12, 7 * HA, 0, 4, 'pit', []],
                    [12, 7 * HA, 0, 4, 'pit', []],
                    [12, 7 * HA, 0, 4, 'pit', []],
                    [12, 7 * HA, 0, 4, 'pit', []],
                    [12, 7 * HA, 0, 4, 'pit', []],
                    [12, 7 * HA, 0, 4, 'pit', []],
                    [12, 7 * HA, 0, 4, 'pit', []],
                    [12, 7 * HA, 0, 4, 'pit', []],
                    [12, 7 * HA, 0, 4, 'pit', []],
                    [12, 7 * HA, 0, 4, 'pit', []],
                    [10, 8 * HA, 0, 4, 'pit', []],
                    [10, 7 * HA, 0, 4, 'pit', []],
                    [10, 6 * HA, 0, 4, 'pit', []],
                    [10, 5 * HA, 0, 4, 'pit', []],
                    [10, 4 * HA, 0, 4, 'pit', []],
                    [8, 7 * HA, 0, 4, 'pit', []],
                    [8, 6 * HA, 0, 4, 'pit', []],
                    [8, 5 * HA, 0, 4, 'pit', []],
                    [8, 4 * HA, 0, 4, 'pit', []],
                    [6, 8 * HA, 0, 4, 'pit', []],
                    [6, 7 * HA, 0, 4, 'pit', []],
                    [6, 6 * HA, 0, 4, 'pit', []],
                    [6, 5 * HA, 0, 4, 'pit', []],
                    [6, 4 * HA, 0, 4, 'pit', []],
                    [14, 4 * HA, 1, 1, 'door', []],
                    [14, 5 * HA, 1, 1, 'door', []],
                ],
                [ //4
                    [3, 7 * HA, 0, 4, 'pit', []],
                    [4, 7 * HA, 0, 4, 'pit', []],
                    [2, 5 * HA, 0, 4, 'pit', []],
                    [2, 4 * HA, 0, 4, 'pit', []],
                    [2, 2 * HA, 0, 4, 'pit', []],
                    [3, 5 * HA, 0, 4, 'pit', []],
                    [4, 5 * HA, 0, 4, 'pit', []],
                    [5, 5 * HA, 0, 4, 'pit', []],
                    [6, 5 * HA, 0, 4, 'pit', []],
                    [6, 6 * HA, 0, 4, 'pit', []],
                    [6, 7 * HA, 0, 4, 'pit', []],
                    [6, 8 * HA, 0, 4, 'pit', []],
                    [6, 4 * HA, 0, 4, 'pit', []],
                    [6, 3 * HA, 0, 4, 'pit', []],
                    [6, 3 * HA, 0, 4, 'pit', []],
                    [2, 7 * HA, 0, 4, 'pit', []],
                    [3, 4 * HA, 0, 4, 'pit', []],
                    [4, 4 * HA, 0, 4, 'pit', []],
                    [4, 3 * HA, 0, 4, 'pit', []],
                    [4, 2 * HA, 0, 4, 'pit', []],
                    [3, 2 * HA, 0, 4, 'pit', []],
                    [2, 2 * HA, 0, 4, 'pit', []],
                    [7, 3 * HA, 0, 4, 'pit', []],
                    [8, 3 * HA, 0, 4, 'pit', []],
                    [9, 3 * HA, 0, 4, 'pit', []],
                    [10, 3 * HA, 0, 4, 'pit', []],
                    [11, 3 * HA, 0, 4, 'pit', []],
                    [12, 3 * HA, 0, 4, 'pit', []],
                    [7, 1 * HA, 0, 4, 'pit', []],
                    [8, 1 * HA, 0, 4, 'pit', []],
                    [9, 1 * HA, 0, 4, 'pit', []],
                    [10, 1 * HA, 0, 4, 'pit', []],
                    [11, 1 * HA, 0, 4, 'pit', []],
                    [12, 1 * HA, 0, 4, 'pit', []],
                    [8, 5 * HA, 0, 4, 'pit', []],
                    [8, 6 * HA, 0, 4, 'pit', []],
                    [8, 7 * HA, 0, 4, 'pit', []],
                    [9, 7 * HA, 0, 4, 'pit', []],
                    [10, 7 * HA, 0, 4, 'pit', []],
                    [11, 7 * HA, 0, 4, 'pit', []],
                    [11, 6 * HA, 0, 4, 'pit', []],
                    [12, 6 * HA, 0, 4, 'pit', []],
                    [13, 6 * HA, 0, 4, 'pit', []],
                    [14, 4 * HA, 1, 1, 'door', []],
                    [14, 5 * HA, 1, 1, 'door', []],
                ],
                [ //5.2
                    [2, 2 * HA, 0, 4, 'pit', []],
                    [3, 2 * HA, 0, 4, 'pit', []],
                    [3, 3 * HA, 0, 4, 'pit', []],
                    [3, 4 * HA, 0, 4, 'pit', []],
                    [3, 6 * HA, 0, 4, 'pit', []],
                    [3, 7 * HA, 0, 4, 'pit', []],
                    [4, 7 * HA, 0, 4, 'pit', []],
                    [5, 7 * HA, 0, 4, 'pit', []],
                    [6, 7 * HA, 0, 4, 'pit', []],
                    [8, 7 * HA, 0, 4, 'pit', []],
                    [9, 7 * HA, 0, 4, 'pit', []],
                    [10, 7 * HA, 0, 4, 'pit', []],
                    [11, 7 * HA, 0, 4, 'pit', []],
                    [12, 7 * HA, 0, 4, 'pit', []],
                    [13, 7 * HA, 0, 4, 'pit', []],
                    [8, 8 * HA, 0, 4, 'pit', []],
                    [9, 8 * HA, 0, 4, 'pit', []],
                    [10, 8 * HA, 0, 4, 'pit', []],
                    [11, 8 * HA, 0, 4, 'pit', []],
                    [12, 8 * HA, 0, 4, 'pit', []],
                    [13, 8 * HA, 0, 4, 'pit', []],
                    [13, 6 * HA, 0, 4, 'pit', []],
                    [12, 6 * HA, 0, 4, 'pit', []],
                    [11, 6 * HA, 0, 4, 'pit', []],
                    [13, 5 * HA, 0, 4, 'pit', []],
                    [12, 5 * HA, 0, 4, 'pit', []],
                    [6, 1 * HA, 0, 4, 'pit', []],
                    [6, 3 * HA, 0, 4, 'pit', []],
                    [6, 4 * HA, 0, 4, 'pit', []],
                    [6, 5 * HA, 0, 4, 'pit', []],
                    [7, 3 * HA, 0, 4, 'pit', []],
                    [7, 4 * HA, 0, 4, 'pit', []],
                    [7, 5 * HA, 0, 4, 'pit', []],
                    [8, 3 * HA, 0, 4, 'pit', []],
                    [8, 4 * HA, 0, 4, 'pit', []],
                    [8, 5 * HA, 0, 4, 'pit', []],
                    [9, 3 * HA, 0, 4, 'pit', []],
                    [9, 2 * HA, 0, 4, 'pit', []],
                    [10, 2 * HA, 0, 4, 'pit', []],
                    [11, 2 * HA, 0, 4, 'pit', []],
                    [12, 2 * HA, 0, 4, 'pit', []],
                    [14, 4 * HA, 1, 1, 'door', []],
                    [14, 5 * HA, 0, 1, 'wall', []],
                ],
                [ //6
                    [12, 2 * HA, 0, 4, 'pit', []],
                ]
            ];
            var walls;

            function loadLevels() { // creates walls and more info
                for (let tt = 0; tt < wallsStartPoss.length; tt++) { //automaticly creates all the walls on any new level
                    for (let i = 0; i < verticalAmount; i++) { //left and right walls
                        let leftwall = 0;
                        let rightwall = 1;
                        if (i == 0) {
                            leftwall = 5;
                            rightwall = 6;
                        }
                        if (i == verticalAmount - 1) {
                            leftwall = 7;
                            rightwall = 8;
                        }

                        if (i !== 5 && i !== 4) { // leaves a 2 gap for the player to walk through
                            wallsStartPoss[tt].push([0, i * HA, 0, leftwall, 'wall', []], [HA - 1, i * HA, 0, rightwall, 'wall', []]);
                        } else {
                            wallsStartPoss[tt].push([0, i * HA, 0, leftwall, 'wall', []]);
                        }
                    }
                    for (let i = 0; i < HA; i++) { //top and bottom walls
                        let leftwall = 2;
                        let rightwall = 3;
                        if (i == 0) {
                            leftwall = 5;
                            rightwall = 7;
                        }
                        if (i == HA - 1) {
                            leftwall = 6;
                            rightwall = 8;
                        }
                        wallsStartPoss[tt].push([i, 0 * HA, 0, leftwall, 'wall', []], [i, (verticalAmount - 1) * HA, 0, rightwall, 'wall', []]);
                    }
                }
                for (let uu = 0; uu < wallsStartPoss.length; uu++) { //checks all walls
                    for (let tt = 0; tt < wallsStartPoss[uu].length; tt++) { //checks if any wall is next to it
                        let leftcheck = false;
                        let rightcheck = false;
                        let upcheck = false;
                        let downcheck = false;
                        let leftUpcheck = false;
                        let rightUpcheck = false;
                        let leftDowncheck = false;
                        let rightDowncheck = false;
                        for (let yy = 0; yy < wallsStartPoss[uu].length; yy++) { //checks all wals positions to its corners and sides
                            if (wallsStartPoss[uu][yy][4] == 'pit') {
                                if (wallsStartPoss[uu][tt][0] + 1 == wallsStartPoss[uu][yy][0] && wallsStartPoss[uu][tt][1] == wallsStartPoss[uu][yy][1]) {
                                    rightcheck = true;
                                }
                                if (wallsStartPoss[uu][tt][0] - 1 == wallsStartPoss[uu][yy][0] && wallsStartPoss[uu][tt][1] == wallsStartPoss[uu][yy][1]) {
                                    leftcheck = true;
                                }
                                if (wallsStartPoss[uu][tt][0] == wallsStartPoss[uu][yy][0] && wallsStartPoss[uu][tt][1] + HA == wallsStartPoss[uu][yy][1]) {
                                    downcheck = true;
                                }
                                if (wallsStartPoss[uu][tt][0] == wallsStartPoss[uu][yy][0] && wallsStartPoss[uu][tt][1] - HA == wallsStartPoss[uu][yy][1]) {
                                    upcheck = true;
                                }
                                if (wallsStartPoss[uu][tt][0] - 1 == wallsStartPoss[uu][yy][0] && wallsStartPoss[uu][tt][1] - HA == wallsStartPoss[uu][yy][1]) {
                                    leftUpcheck = true;
                                }
                                if (wallsStartPoss[uu][tt][0] + 1 == wallsStartPoss[uu][yy][0] && wallsStartPoss[uu][tt][1] - HA == wallsStartPoss[uu][yy][1]) {
                                    rightUpcheck = true;
                                }
                                if (wallsStartPoss[uu][tt][0] - 1 == wallsStartPoss[uu][yy][0] && wallsStartPoss[uu][tt][1] + HA == wallsStartPoss[uu][yy][1]) {
                                    leftDowncheck = true;
                                }
                                if (wallsStartPoss[uu][tt][0] + 1 == wallsStartPoss[uu][yy][0] && wallsStartPoss[uu][tt][1] + HA == wallsStartPoss[uu][yy][1]) {
                                    rightDowncheck = true;
                                }
                            }
                        }
                        if (wallsStartPoss[uu][tt][4] == 'pit') { // if there were any walls next to this wall it will designate a spesific sprite, anmd have special corner pices if there wasent one in the corner
                            if (leftcheck == true && rightcheck == false && upcheck == false && downcheck == false) { //left
                                wallsStartPoss[uu][tt][3] = 20;
                            } else if (leftcheck == true && rightcheck == true && upcheck == false && downcheck == false) { //left-right
                                wallsStartPoss[uu][tt][3] = 22;
                            } else if (leftcheck == true && rightcheck == true && upcheck == true && downcheck == false) { // left right up
                                wallsStartPoss[uu][tt][3] = 12;
                                if (leftUpcheck == false) {
                                    wallsStartPoss[uu][tt][5].push(1);
                                }
                                if (rightUpcheck == false) {
                                    wallsStartPoss[uu][tt][5].push(2);
                                }
                            } else if (leftcheck == true && rightcheck == true && upcheck == true && downcheck == true) { // all
                                wallsStartPoss[uu][tt][3] = 23;
                                if (leftUpcheck == false) {
                                    wallsStartPoss[uu][tt][5].push(1);
                                }
                                if (rightUpcheck == false) {
                                    wallsStartPoss[uu][tt][5].push(2);
                                }
                                if (leftDowncheck == false) {
                                    wallsStartPoss[uu][tt][5].push(3);
                                }
                                if (rightDowncheck == false) {
                                    wallsStartPoss[uu][tt][5].push(4);
                                }
                            } else if (leftcheck == false && rightcheck == true && upcheck == false && downcheck == false) { //right
                                wallsStartPoss[uu][tt][3] = 19;
                            } else if (leftcheck == true && rightcheck == false && upcheck == true && downcheck == false) { //left up
                                wallsStartPoss[uu][tt][3] = 16;
                                if (leftUpcheck == false) {
                                    wallsStartPoss[uu][tt][5].push(1);
                                }
                            } else if (leftcheck == true && rightcheck == false && upcheck == false && downcheck == true) { //left down
                                wallsStartPoss[uu][tt][3] = 14;
                                if (leftDowncheck == false) {
                                    wallsStartPoss[uu][tt][5].push(1);
                                }
                            } else if (leftcheck == true && rightcheck == false && upcheck == true && downcheck == true) { //left down up
                                wallsStartPoss[uu][tt][3] = 10;
                                if (leftDowncheck == false) {
                                    wallsStartPoss[uu][tt][5].push(1);
                                }
                                if (leftUpcheck == false) {
                                    wallsStartPoss[uu][tt][5].push(2);
                                }
                            } else if (leftcheck == true && rightcheck == true && upcheck == false && downcheck == true) { //left right down
                                wallsStartPoss[uu][tt][3] = 11;
                                if (leftDowncheck == false) {
                                    wallsStartPoss[uu][tt][5].push(1);
                                }
                                if (rightDowncheck == false) {
                                    wallsStartPoss[uu][tt][5].push(2);
                                }
                            } else if (leftcheck == false && rightcheck == true && upcheck == true && downcheck == true) { //right up down
                                wallsStartPoss[uu][tt][3] = 9;
                                if (rightUpcheck == false) {
                                    wallsStartPoss[uu][tt][5].push(1);
                                }
                                if (rightDowncheck == false) {
                                    wallsStartPoss[uu][tt][5].push(2);
                                }
                            } else if (leftcheck == false && rightcheck == false && upcheck == true && downcheck == true) { //up down
                                wallsStartPoss[uu][tt][3] = 21;
                            } else if (leftcheck == false && rightcheck == true && upcheck == true && downcheck == false) { //right up
                                wallsStartPoss[uu][tt][3] = 15;
                                if (rightUpcheck == false) {
                                    wallsStartPoss[uu][tt][5].push(1);
                                }
                            } else if (leftcheck == false && rightcheck == false && upcheck == true && downcheck == false) { //up
                                wallsStartPoss[uu][tt][3] = 17;
                            } else if (leftcheck == false && rightcheck == false && upcheck == false && downcheck == true) { //down
                                wallsStartPoss[uu][tt][3] = 18;
                            } else if (leftcheck == false && rightcheck == true && upcheck == false && downcheck == true) { //right down
                                wallsStartPoss[uu][tt][3] = 13;
                                if (rightDowncheck == false) {
                                    wallsStartPoss[uu][tt][5].push(1);
                                }
                            } else {
                                wallsStartPoss[uu][tt][3] = 4;
                            }
                        }
                    }
                }
            }

        </script>
    </canvas>
    <style>
        html {
            background-color: black;
        }

    </style>
</body>

</html>
